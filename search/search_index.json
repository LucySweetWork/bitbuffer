{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BitBuffer is a bit stream module implemented in pure Lua. Its purpose is to provide an easy way to write and read binary data down to the bit level. It first found life as a replacement for a module that performed rather poorly, and was primarily meant for use on Roblox. However, no Roblox specific API is used in the main file or tests of the module. The module was written and tested using Lua 5.2, though any version of Lua that has a bit module should be able to run this module with a few modifications. It will probably perform best with LuaJIT, as Roblox's Lua VM is extremely fast compared to PUC-Rio and this module makes use of some specific optimizations (ipairs, as an example, is faster than a numeric for in Roblox). Why? \u00b6 Numbers take up a lot of space. Take the number 24930 . When written out, it's 5 bytes. That's not an awful lot, but if you had to save hundreds of thousands of numbers of a similiar size, that's a lot of space spent on numbers alone. When written with this BitBuffer though, 24930 only takes up 2 bytes and becomes ab . Interested how? The number 24930 is 110000101100010 in binary, which is 15 bits long. Padding it to be exactly 16 bits (2 bytes evenly), it becomes 110000101100010 . That can be split into 01100001 and 01100010 , which are equivalent to a and b respectively. Thus, ab is the binary equivalent to 24930 . Obviously, the two bytes taken up by ab is less than the 5 bytes taken up by 24930 . This difference gets a lot more dramatic the bigger the number: 1633837924 is 10 bytes to write out but in binary is abcd , and 107075202213222 is 15 bytes but turns into abcdef . That's a difference of 9 bytes per number! Support \u00b6 By default, the BitBuffer only supports basic data types (specifically bits, integers, floats, and strings) and some common variants of them. Custom structs (Vectors, coordinates, etc.) can be added rather easily by modifying the module however. An example of this is found under Customization . The module also obviously supports importing and exporting data to and from the stream. The constructor takes a string, which it will convert to a stream, and a buffer object has some functions to easily export the data inside. These are documented in Main Functions . Limitations \u00b6 A limit for the width of all numbers is hardcoded to be 64-bits. However, as Lua numbers are doubles, the maximum precision for them is actually 53 bits. If you need to store numbers at that size, you should consider alternatives regardless of whether you use the BitBuffer. Technical details \u00b6 Data written with the BitBuffer is big-endian. It follows the IEEE-754 format for floating points. Signed integers are stored using two's complements, as you would expect. By default, strings are written and read by prefixing the length as an unsigned 24-bit integer. There are a variety of tests that can be run in the tests folder to verify the functionality of the module. They expect a file named bitbuffer.lua that contains the main module.","title":"Home"},{"location":"#why","text":"Numbers take up a lot of space. Take the number 24930 . When written out, it's 5 bytes. That's not an awful lot, but if you had to save hundreds of thousands of numbers of a similiar size, that's a lot of space spent on numbers alone. When written with this BitBuffer though, 24930 only takes up 2 bytes and becomes ab . Interested how? The number 24930 is 110000101100010 in binary, which is 15 bits long. Padding it to be exactly 16 bits (2 bytes evenly), it becomes 110000101100010 . That can be split into 01100001 and 01100010 , which are equivalent to a and b respectively. Thus, ab is the binary equivalent to 24930 . Obviously, the two bytes taken up by ab is less than the 5 bytes taken up by 24930 . This difference gets a lot more dramatic the bigger the number: 1633837924 is 10 bytes to write out but in binary is abcd , and 107075202213222 is 15 bytes but turns into abcdef . That's a difference of 9 bytes per number!","title":"Why?"},{"location":"#support","text":"By default, the BitBuffer only supports basic data types (specifically bits, integers, floats, and strings) and some common variants of them. Custom structs (Vectors, coordinates, etc.) can be added rather easily by modifying the module however. An example of this is found under Customization . The module also obviously supports importing and exporting data to and from the stream. The constructor takes a string, which it will convert to a stream, and a buffer object has some functions to easily export the data inside. These are documented in Main Functions .","title":"Support"},{"location":"#limitations","text":"A limit for the width of all numbers is hardcoded to be 64-bits. However, as Lua numbers are doubles, the maximum precision for them is actually 53 bits. If you need to store numbers at that size, you should consider alternatives regardless of whether you use the BitBuffer.","title":"Limitations"},{"location":"#technical-details","text":"Data written with the BitBuffer is big-endian. It follows the IEEE-754 format for floating points. Signed integers are stored using two's complements, as you would expect. By default, strings are written and read by prefixing the length as an unsigned 24-bit integer. There are a variety of tests that can be run in the tests folder to verify the functionality of the module. They expect a file named bitbuffer.lua that contains the main module.","title":"Technical details"},{"location":"api-base/","text":"This page covers all of the abstract functions of the BitBuffer. These functions allow for writing arbitrarily sized numbers and bits, and shouldn't be used for most projects. For the main functions, including the constructor and export functions, see Main Functions . Functions that are specific to the Roblox version of the BitBuffer are documented in Roblox Functions . Potential Performance Issue Although these functions allow for reading and writing arbitrarily sized numbers, it can cause performance problems for subsequent function calls because of the math involved unless the bits involved are clean multiples of 8. As an example, if writeUnsigned(12, 0) was called, every subsequent write function call will be slower until the total length of the BitBuffer is a multiple of 8. The same is true of read functions -- readUnsigned(12) causes performance issues for read functions until the total bits read are a multiple of 8. Write functions \u00b6 writeBits \u00b6 BitBuffer.writeBits(...: integer) -> nil Writes an arbitrary number of bits to the BitBuffer. The arguments MUST all be 0 or 1. writeByte \u00b6 BitBuffer.writeByte(n: integer) -> nil Writes a byte to the BitBuffer. writeUnsigned \u00b6 BitBuffer.writeUnsigned(width: integer, n: integer) -> nil Writes an arbitrary width unsigned integer to the BitBuffer.The width MUST be in the range [1, 64] writeSigned \u00b6 BitBuffer.writeSigned(width: integer, n: integer) -> nil Writes an arbitrary width signed integer to the BitBuffer. The width MUST be in the range [2, 63] writeFloat \u00b6 Floating point numbers are complicated! Try reading the source to learn more about this function. BitBuffer.writeFloat(expWidth: integer, mantWidth: integer, n: number) -> nil Writes a floating point number with an arbitrarily long exponent and an arbitrarily long mantissa to the BitBuffer. expWidth is the length of the exponent and mantWidth is the length of the mantissa. Both expWidth and mantWidth MUST be in the range [1, 64]. Read functions \u00b6 readBits \u00b6 BitBuffer.readBits(n: integer) -> Array<integer> Reads n bits from the BitBuffer and returns them in an array of 1s and 0s. readByte \u00b6 BitBuffer.readByte() -> integer Reads a byte from the BitBuffer and returns it. readUnsigned \u00b6 BitBuffer.readUnsigned(width: integer) -> integer Reads an arbitrary width unsigned integer from the BitBuffer and returns it. The width MUST be in the range [1, 64] readSigned \u00b6 BitBuffer.readSigned(width: integer) -> integer Reads an arbitrary width signed integer from the BitBuffer and returns it. The width MUST be in the range [2, 63] readFloat \u00b6 BitBuffer.readFloat(expWidth: integer, mantWidth: integer) -> number Reads a floating point number with an arbitrarily long exponent and an arbitrarily long mantissa from the BitBuffer and returns it. expWidth is the length of the exponent and mantWidth is the length of the mantissa. Both expWidth and mantWidth MUST be in the range [1, 64].","title":"Abstract Functions"},{"location":"api-base/#write-functions","text":"","title":"Write functions"},{"location":"api-base/#writebits","text":"BitBuffer.writeBits(...: integer) -> nil Writes an arbitrary number of bits to the BitBuffer. The arguments MUST all be 0 or 1.","title":"writeBits"},{"location":"api-base/#writebyte","text":"BitBuffer.writeByte(n: integer) -> nil Writes a byte to the BitBuffer.","title":"writeByte"},{"location":"api-base/#writeunsigned","text":"BitBuffer.writeUnsigned(width: integer, n: integer) -> nil Writes an arbitrary width unsigned integer to the BitBuffer.The width MUST be in the range [1, 64]","title":"writeUnsigned"},{"location":"api-base/#writesigned","text":"BitBuffer.writeSigned(width: integer, n: integer) -> nil Writes an arbitrary width signed integer to the BitBuffer. The width MUST be in the range [2, 63]","title":"writeSigned"},{"location":"api-base/#writefloat","text":"Floating point numbers are complicated! Try reading the source to learn more about this function. BitBuffer.writeFloat(expWidth: integer, mantWidth: integer, n: number) -> nil Writes a floating point number with an arbitrarily long exponent and an arbitrarily long mantissa to the BitBuffer. expWidth is the length of the exponent and mantWidth is the length of the mantissa. Both expWidth and mantWidth MUST be in the range [1, 64].","title":"writeFloat"},{"location":"api-base/#read-functions","text":"","title":"Read functions"},{"location":"api-base/#readbits","text":"BitBuffer.readBits(n: integer) -> Array<integer> Reads n bits from the BitBuffer and returns them in an array of 1s and 0s.","title":"readBits"},{"location":"api-base/#readbyte","text":"BitBuffer.readByte() -> integer Reads a byte from the BitBuffer and returns it.","title":"readByte"},{"location":"api-base/#readunsigned","text":"BitBuffer.readUnsigned(width: integer) -> integer Reads an arbitrary width unsigned integer from the BitBuffer and returns it. The width MUST be in the range [1, 64]","title":"readUnsigned"},{"location":"api-base/#readsigned","text":"BitBuffer.readSigned(width: integer) -> integer Reads an arbitrary width signed integer from the BitBuffer and returns it. The width MUST be in the range [2, 63]","title":"readSigned"},{"location":"api-base/#readfloat","text":"BitBuffer.readFloat(expWidth: integer, mantWidth: integer) -> number Reads a floating point number with an arbitrarily long exponent and an arbitrarily long mantissa from the BitBuffer and returns it. expWidth is the length of the exponent and mantWidth is the length of the mantissa. Both expWidth and mantWidth MUST be in the range [1, 64].","title":"readFloat"},{"location":"api-main/","text":"This page covers all of the main functions of the BitBuffer. These include the constructor, functions to get the data out of the BitBuffer, and its main read/write functions. Abstract functions, like writeUnsigned (which allows writing an integer of arbitrary size) aren't documented on this page since they shouldn't generally see use in a normal project. However, they're still useful and are thus documented in Abstract Functions . Functions that are specific to the Roblox version of the BitBuffer are documented in Roblox Functions . Type Information This API reference provides the argument and return types for the various functions. They will hopefully be self-explanatory, but as a brief overview, the type of arguments look like this: x: number and means that x is a number . If an argument's type is followed by a ? , it means the argument is optional. The return type of a function follows a -> . Thus, BitBuffer(stream: string?) -> BitBuffer means that the function BitBuffer optionally takes a string as an argument and returns a BitBuffer. BitBuffer \u00b6 Constructor \u00b6 BitBuffer(stream: string?) -> BitBuffer Creates a new BitBuffer object and fills it with stream if it's provided. Otherwise, returns an empty BitBuffer. getPointer \u00b6 BitBuffer.getPointer() -> integer Returns where the pointer is in the stream. The pointer is the bit from which the various Read functions operate. setPointer \u00b6 BitBuffer.setPointer(n: integer) -> nil Sets where the pointer is in the stream. Export functions \u00b6 The following functions are all intended to get data out of the BitBuffer in some way. dumpBinary \u00b6 BitBuffer.dumpBinary() -> string Returns a string of binary digits that represents the content of the BitBuffer. This is primarily intended for debugging or testing purposes. dumpString \u00b6 BitBuffer.dumpString() -> string Returns the raw binary content of the BitBuffer. This function is one of the main methods for getting things out of the buffer, and outputs the raw binary data. dumpBase64 \u00b6 BitBuffer.dumpBase64() -> string Returns the base64 encoded content of the BitBuffer. This function doesn't add linebreaks to the data. dumpHex \u00b6 BitBuffer.dumpHex() -> string Returns a string of hex characters representing the contents of the BitBuffer. crc32 \u00b6 BitBuffer.crc32() -> integer Returns the CRC-32 checksum of the BitBuffer's contents. Write functions \u00b6 The following functions are all intended to write data to the BitBuffer. With little exception, they're more efficient than calling their abstract equivalents and should be used over them. writeUInt8 \u00b6 BitBuffer.writeUInt8(n: integer) -> nil Writes the unsigned 8-bit integer n to the BitBuffer. Directly calls BitBuffer.writeByte , but included for the sake of completion. writeUInt16 \u00b6 BitBuffer.writeUInt16(n: integer) -> nil Writes the unsigned 16-bit integer n to the BitBuffer. writeUInt32 \u00b6 BitBuffer.writeUInt32(n: integer) -> nil Writes the unsigned 32-bit integer n to the BitBuffer. writeInt8 \u00b6 BitBuffer.writeUInt8(n: integer) -> nil Writes the signed 8-bit integer n to the BitBuffer. writeInt16 \u00b6 BitBuffer.writeUInt16(n: integer) -> nil Writes the signed 16-bit integer n to the BitBuffer. writeInt32 \u00b6 BitBuffer.writeUInt32(n: integer) -> nil Writes the signed 32-bit integer n to the BitBuffer. writeFloat16 \u00b6 BitBuffer.writeFloat16(n: number) -> nil Writes a half-precision (16-bit) floating point number to the BitBuffer. writeFloat32 \u00b6 BitBuffer.writeFloat32(n: number) -> nil Writes a single-precision (32-bit) floating point number to the BitBuffer. writeFloat64 \u00b6 BitBuffer.writeFloat64(n: number) -> nil Writes a double-precision (64-bit) floating point number to the BitBuffer. In most installs of Lua (including Roblox), all Lua numbers are doubles, so this should be used if the precision of a number is important. writeString \u00b6 BitBuffer.writeString(str: string) -> nil Writes a length-prefixed string to the BitBuffer. The length is written as a 24-bit unsigned integer before the bytes of the string. writeTerminatedString \u00b6 BitBuffer.writeTerminatedString(str: string) -> nil Writes a null-terminated string to the BitBuffer. For efficiency's sake, this function doesn't check to see if str contains an embedded \\0 character, so plan accordingly. writeSetLengthString \u00b6 BitBuffer.writeSetLengthString(str: string) -> nil Writes a set-length string to the BitBuffer. No information is stored about the length of the string -- readSetLengthString requires the length of the written string to read. writeField \u00b6 Potential Performance Issue Although this function allows for writing fields that aren't a multiple of 8 bits long, it can cause performance problems for subsequent writes because of the math involved. You should try to keep writeField calls to the end of the file or make sure they're multiples of 8. BitBuffer.writeField(...: any) -> nil Writes a bitfield with a bit for every argument passed. If the argument is truthy, the bit is 1 . Otherwise, it's false . The max number of arguments able to be passed to this function is 53 (see the section on limitations ). Read functions \u00b6 The following functions are all intended to read data from the BitBuffer. With little exception, they're more efficient than calling their abstract equivalents and should be used over them. readUInt8 \u00b6 BitBuffer.readUInt8() -> integer Reads an 8-bit unsigned integer from the BitBuffer and returns it. readUInt16 \u00b6 BitBuffer.readUInt16() -> integer Reads a 16-bit unsigned integer from the BitBuffer and returns it. readUInt32 \u00b6 BitBuffer.readUInt32() -> integer Reads a 32-bit unsigned integer from the BitBuffer and returns it. readInt8 \u00b6 BitBuffer.readInt8() -> integer Reads an 8-bit signed integer from the BitBuffer and returns it. readInt16 \u00b6 BitBuffer.readInt16() -> integer Reads a 16-bit signed integer from the BitBuffer and returns it. readInt32 \u00b6 BitBuffer.readInt32() -> integer Reads an 32-bit signed integer from the BitBuffer and returns it. readFloat16 \u00b6 BitBuffer.readFloat16() -> number Reads a half-precision (16-bit) floating point number from the BitBuffer and returns it. readFloat32 \u00b6 BitBuffer.readFloat32() -> number Reads a single-precision (32-bit) floating point number from the BitBuffer and returns it. readFloat64 \u00b6 BitBuffer.readFloat64() -> number Reads a double-precision (64-bit) floating point number from the BitBuffer and returns it. readString \u00b6 BitBuffer.readString() -> string Reads a length-prefixed string from the BitBuffer and returns it. readTerminatedString \u00b6 BitBuffer.readTerminatedString() -> string Reads a null-terminated string from the BitBuffer and returns it. readSetLengthString \u00b6 BitBuffer.readSetLengthString(length: integer) -> string Reads a length byte string from the BitBuffer and returns it. readField \u00b6 Potential Performance Issue Although this function allows for reading fields that aren't a multiple of 8 bits long, it can cause performance problems for subsequent reads because of the math involved. You should try to keep readField calls to the end of the file or make sure they're multiples of 8. BitBuffer.readField(n: integer) -> Array<boolean> Reads an n width bitfield from the BitBuffer and returns an array of bools that represent its bits.","title":"Main Functions"},{"location":"api-main/#bitbuffer","text":"","title":"BitBuffer"},{"location":"api-main/#constructor","text":"BitBuffer(stream: string?) -> BitBuffer Creates a new BitBuffer object and fills it with stream if it's provided. Otherwise, returns an empty BitBuffer.","title":"Constructor"},{"location":"api-main/#getpointer","text":"BitBuffer.getPointer() -> integer Returns where the pointer is in the stream. The pointer is the bit from which the various Read functions operate.","title":"getPointer"},{"location":"api-main/#setpointer","text":"BitBuffer.setPointer(n: integer) -> nil Sets where the pointer is in the stream.","title":"setPointer"},{"location":"api-main/#export-functions","text":"The following functions are all intended to get data out of the BitBuffer in some way.","title":"Export functions"},{"location":"api-main/#dumpbinary","text":"BitBuffer.dumpBinary() -> string Returns a string of binary digits that represents the content of the BitBuffer. This is primarily intended for debugging or testing purposes.","title":"dumpBinary"},{"location":"api-main/#dumpstring","text":"BitBuffer.dumpString() -> string Returns the raw binary content of the BitBuffer. This function is one of the main methods for getting things out of the buffer, and outputs the raw binary data.","title":"dumpString"},{"location":"api-main/#dumpbase64","text":"BitBuffer.dumpBase64() -> string Returns the base64 encoded content of the BitBuffer. This function doesn't add linebreaks to the data.","title":"dumpBase64"},{"location":"api-main/#dumphex","text":"BitBuffer.dumpHex() -> string Returns a string of hex characters representing the contents of the BitBuffer.","title":"dumpHex"},{"location":"api-main/#crc32","text":"BitBuffer.crc32() -> integer Returns the CRC-32 checksum of the BitBuffer's contents.","title":"crc32"},{"location":"api-main/#write-functions","text":"The following functions are all intended to write data to the BitBuffer. With little exception, they're more efficient than calling their abstract equivalents and should be used over them.","title":"Write functions"},{"location":"api-main/#writeuint8","text":"BitBuffer.writeUInt8(n: integer) -> nil Writes the unsigned 8-bit integer n to the BitBuffer. Directly calls BitBuffer.writeByte , but included for the sake of completion.","title":"writeUInt8"},{"location":"api-main/#writeuint16","text":"BitBuffer.writeUInt16(n: integer) -> nil Writes the unsigned 16-bit integer n to the BitBuffer.","title":"writeUInt16"},{"location":"api-main/#writeuint32","text":"BitBuffer.writeUInt32(n: integer) -> nil Writes the unsigned 32-bit integer n to the BitBuffer.","title":"writeUInt32"},{"location":"api-main/#writeint8","text":"BitBuffer.writeUInt8(n: integer) -> nil Writes the signed 8-bit integer n to the BitBuffer.","title":"writeInt8"},{"location":"api-main/#writeint16","text":"BitBuffer.writeUInt16(n: integer) -> nil Writes the signed 16-bit integer n to the BitBuffer.","title":"writeInt16"},{"location":"api-main/#writeint32","text":"BitBuffer.writeUInt32(n: integer) -> nil Writes the signed 32-bit integer n to the BitBuffer.","title":"writeInt32"},{"location":"api-main/#writefloat16","text":"BitBuffer.writeFloat16(n: number) -> nil Writes a half-precision (16-bit) floating point number to the BitBuffer.","title":"writeFloat16"},{"location":"api-main/#writefloat32","text":"BitBuffer.writeFloat32(n: number) -> nil Writes a single-precision (32-bit) floating point number to the BitBuffer.","title":"writeFloat32"},{"location":"api-main/#writefloat64","text":"BitBuffer.writeFloat64(n: number) -> nil Writes a double-precision (64-bit) floating point number to the BitBuffer. In most installs of Lua (including Roblox), all Lua numbers are doubles, so this should be used if the precision of a number is important.","title":"writeFloat64"},{"location":"api-main/#writestring","text":"BitBuffer.writeString(str: string) -> nil Writes a length-prefixed string to the BitBuffer. The length is written as a 24-bit unsigned integer before the bytes of the string.","title":"writeString"},{"location":"api-main/#writeterminatedstring","text":"BitBuffer.writeTerminatedString(str: string) -> nil Writes a null-terminated string to the BitBuffer. For efficiency's sake, this function doesn't check to see if str contains an embedded \\0 character, so plan accordingly.","title":"writeTerminatedString"},{"location":"api-main/#writesetlengthstring","text":"BitBuffer.writeSetLengthString(str: string) -> nil Writes a set-length string to the BitBuffer. No information is stored about the length of the string -- readSetLengthString requires the length of the written string to read.","title":"writeSetLengthString"},{"location":"api-main/#writefield","text":"Potential Performance Issue Although this function allows for writing fields that aren't a multiple of 8 bits long, it can cause performance problems for subsequent writes because of the math involved. You should try to keep writeField calls to the end of the file or make sure they're multiples of 8. BitBuffer.writeField(...: any) -> nil Writes a bitfield with a bit for every argument passed. If the argument is truthy, the bit is 1 . Otherwise, it's false . The max number of arguments able to be passed to this function is 53 (see the section on limitations ).","title":"writeField"},{"location":"api-main/#read-functions","text":"The following functions are all intended to read data from the BitBuffer. With little exception, they're more efficient than calling their abstract equivalents and should be used over them.","title":"Read functions"},{"location":"api-main/#readuint8","text":"BitBuffer.readUInt8() -> integer Reads an 8-bit unsigned integer from the BitBuffer and returns it.","title":"readUInt8"},{"location":"api-main/#readuint16","text":"BitBuffer.readUInt16() -> integer Reads a 16-bit unsigned integer from the BitBuffer and returns it.","title":"readUInt16"},{"location":"api-main/#readuint32","text":"BitBuffer.readUInt32() -> integer Reads a 32-bit unsigned integer from the BitBuffer and returns it.","title":"readUInt32"},{"location":"api-main/#readint8","text":"BitBuffer.readInt8() -> integer Reads an 8-bit signed integer from the BitBuffer and returns it.","title":"readInt8"},{"location":"api-main/#readint16","text":"BitBuffer.readInt16() -> integer Reads a 16-bit signed integer from the BitBuffer and returns it.","title":"readInt16"},{"location":"api-main/#readint32","text":"BitBuffer.readInt32() -> integer Reads an 32-bit signed integer from the BitBuffer and returns it.","title":"readInt32"},{"location":"api-main/#readfloat16","text":"BitBuffer.readFloat16() -> number Reads a half-precision (16-bit) floating point number from the BitBuffer and returns it.","title":"readFloat16"},{"location":"api-main/#readfloat32","text":"BitBuffer.readFloat32() -> number Reads a single-precision (32-bit) floating point number from the BitBuffer and returns it.","title":"readFloat32"},{"location":"api-main/#readfloat64","text":"BitBuffer.readFloat64() -> number Reads a double-precision (64-bit) floating point number from the BitBuffer and returns it.","title":"readFloat64"},{"location":"api-main/#readstring","text":"BitBuffer.readString() -> string Reads a length-prefixed string from the BitBuffer and returns it.","title":"readString"},{"location":"api-main/#readterminatedstring","text":"BitBuffer.readTerminatedString() -> string Reads a null-terminated string from the BitBuffer and returns it.","title":"readTerminatedString"},{"location":"api-main/#readsetlengthstring","text":"BitBuffer.readSetLengthString(length: integer) -> string Reads a length byte string from the BitBuffer and returns it.","title":"readSetLengthString"},{"location":"api-main/#readfield","text":"Potential Performance Issue Although this function allows for reading fields that aren't a multiple of 8 bits long, it can cause performance problems for subsequent reads because of the math involved. You should try to keep readField calls to the end of the file or make sure they're multiples of 8. BitBuffer.readField(n: integer) -> Array<boolean> Reads an n width bitfield from the BitBuffer and returns an array of bools that represent its bits.","title":"readField"},{"location":"api-roblox/","text":"This page covers all of the functions specific to the Roblox version of the BitBuffer. These functions allow for reading and writing Roblox specific datatypes to and from the BitBuffer. For the main functions, including the constructor and export functions, see Main Functions . The abstract BitBuffer functions are documented in Abstract Functions . Write functions \u00b6 Read functions \u00b6","title":"Roblox Functions"},{"location":"api-roblox/#write-functions","text":"","title":"Write functions"},{"location":"api-roblox/#read-functions","text":"","title":"Read functions"},{"location":"customization/","text":"Attention Roblox users This is important information, but it's a lot less important for Roblox developers. The Roblox variant of this module already has all of the Roblox data types in it. By default, the BitBuffer doesn't have any complex datatypes in it. It only has the ability to write bits, bytes, unsigned and signed integers, floats, and strings. It also comes out of the box with a few functions to make writing standard sizes more convenient (stuff like being able to call writeUInt32(X) instead of writeUnsigned(32, X) ). For some enviroments, it might make sense to have shorthands for writing longer data pieces though. In the example , there's a table that looks like this: { x = 10.55915 , y = - 15.2222 , } If this sort of structure shows up in data quite often, it would make sense to write a seperate set of functions in the module to write and read it. Those functions can be written and inserted into the module easily and used from there. They should go after all the built-in functions (so that those functions can be used in your own function) and added to the return table at the bottom of the constructor. Functions of that sort can be written as follows. In this example, the data structure is called a Vector2. -- All the other functions above local function writeVector2 ( vector ) buffer . writeFloat32 ( vector . x ) buffer . writeFloat32 ( vector . y ) end local function readVector2 ( vector ) local x = buffer . readFloat32 ( vector . x ) local y = buffer . readFloat32 ( vector . y ) return x , y end return { -- All of the built-in functions writeVector2 = writeVector2 , readVector2 = readVector2 , } If that example isn't sufficient, there are several present in the Roblox version of the module.","title":"Customization"},{"location":"installation/","text":"Installing the module is rather simple. The only file that's needed for the actual BitBuffer is the main one . Copy the contents of that file to a Lua file if you're using vanilla Lua or a ModuleScript if you're using Roblox, and it's ready to go. For Roblox users \u00b6 All Roblox-specific files are stored in the Roblox source folder . If you're using Roblox, you should probably use the files there. The Roblox version makes use of table.create and will eventually have type annotations. The test files are also translated over to work in Roblox, and a Rojo project file is included to build the module and its tests into a model for convenience.","title":"Installation"},{"location":"installation/#for-roblox-users","text":"All Roblox-specific files are stored in the Roblox source folder . If you're using Roblox, you should probably use the files there. The Roblox version makes use of table.create and will eventually have type annotations. The test files are also translated over to work in Roblox, and a Rojo project file is included to build the module and its tests into a model for convenience.","title":"For Roblox users"},{"location":"reading/","text":"This example covers reading binary data with the module If you're interested in using the module to write binary data, check out the first example . The BitBuffer is also designed to easily read binary data. This is useful for all sorts of situations, but for this example the information written in the previous page will be used. To review, that data structure looked like this: local data = { name = \"John Doe\" , health = 100 , maxHealth = 100 , points = 10 , position = { x = 10.55915 , y = - 15.2222 , }, bossesKilled = { true , false , true }, } After the information was written with the BitBuffer to a file, it can be read issue with the buffer. It's as simple as reading the file contents, creating a BitBuffer with the content, and calling the respective read functions in order . If the file is read out of order, or the wrong datatypes are read, it will give unexpected results. local BitBuffer = ... -- The BitBuffer should be required here. local fileContents = ... -- The contents of the file should be put here. local data = {} local buffer = BitBuffer ( fileContents ) -- This creates a new BitBuffer with `fileContents` inside it data . name = buffer : readString () data . health = buffer : readInt16 () data . maxHealth = buffer : readInt16 () data . points = buffer : readInt16 () data . position = { x = buffer : readFloat32 (), y = buffer : readFloat32 (), } data . bossesKilled = buffer : readField ( 3 ) With minimal effort, the data is restored... For the most part. All floating point numbers are subject to minor errors, and unfortunately the BitBuffer is no different. As a result, the position data read above will not be exactly correct. This is unavoidable and cannot be fixed. If you want to minimize floating point errors, use integers, or write Float64s instead of Float32s. Technical Info \u00b6 This section analyzes the actual output of the BitBuffer and looks at what each byte is for the sake of knowledge. If viewed in a hex editor ( HxD is recommended), the above data structure looks like this when written to the file: 00 00 08 4A 6F 68 6E 20 44 6F 65 00 64 00 64 00 0A 41 28 F2 47 C1 73 8E 22 A0 As mentioned above, the data has to be read in the order it was written in. So, data.name is first. Since writeString was used to write the name, a 24-bit unsigned integer was written to indicate how long the string is, then the raw bytes of the string are written. Since the number 0x000008 is 8, the string is 8 bytes long, which means it's 4A 6F 68 6E 20 44 6F 65 or John Doe when translated to ASCII. Next, data.health . This was written as a 16-bit unsigned integer, which means that the value is 0x0064 , or 100 in decimal. This process is repeated for data.maxHealth and data.points , which are 0x0064 and 0x000A (or 100 and 10 ). Next, the position values data.position.x and data.position.y . These were written as 32-bit floating point numbers, which means that 4 bytes have to be read for each, which are 41 28 F2 47 and C1 73 8E 22 respectively. Rather than explaining floating point numbers in full here, these can be plugged into a site like float.exposed to read their values. When plugged into that site (32-bit floats are commonly called singles) 0x4128F247 is 10.5591497421264648438 and 0xC1738E22 is read as -15.2222003936767578125 . Finally, data.bossesKilled is written as a bitfield of three bools. Because individual bits can't be written to a file, the spare 5 bits are filled with 0s and written as well. The last byte in the file ( A0 ) is 10100000 in binary. Reading the first three bits of the byte gives 101 or {true, false, true} .","title":"Reading"},{"location":"reading/#technical-info","text":"This section analyzes the actual output of the BitBuffer and looks at what each byte is for the sake of knowledge. If viewed in a hex editor ( HxD is recommended), the above data structure looks like this when written to the file: 00 00 08 4A 6F 68 6E 20 44 6F 65 00 64 00 64 00 0A 41 28 F2 47 C1 73 8E 22 A0 As mentioned above, the data has to be read in the order it was written in. So, data.name is first. Since writeString was used to write the name, a 24-bit unsigned integer was written to indicate how long the string is, then the raw bytes of the string are written. Since the number 0x000008 is 8, the string is 8 bytes long, which means it's 4A 6F 68 6E 20 44 6F 65 or John Doe when translated to ASCII. Next, data.health . This was written as a 16-bit unsigned integer, which means that the value is 0x0064 , or 100 in decimal. This process is repeated for data.maxHealth and data.points , which are 0x0064 and 0x000A (or 100 and 10 ). Next, the position values data.position.x and data.position.y . These were written as 32-bit floating point numbers, which means that 4 bytes have to be read for each, which are 41 28 F2 47 and C1 73 8E 22 respectively. Rather than explaining floating point numbers in full here, these can be plugged into a site like float.exposed to read their values. When plugged into that site (32-bit floats are commonly called singles) 0x4128F247 is 10.5591497421264648438 and 0xC1738E22 is read as -15.2222003936767578125 . Finally, data.bossesKilled is written as a bitfield of three bools. Because individual bits can't be written to a file, the spare 5 bits are filled with 0s and written as well. The last byte in the file ( A0 ) is 10100000 in binary. Reading the first three bits of the byte gives 101 or {true, false, true} .","title":"Technical Info"},{"location":"writing/","text":"This example covers writing binary data with the module If you're interested in using the module to read binary data, check out the second example . The BitBuffer is designed to have both a simple and powerful API. As a rather contrived example, imagine you were developing a game and had the following data: local data = { name = \"John Doe\" , health = 100 , maxHealth = 100 , points = 10 , position = { x = 10.55915 , y = - 15.2222 , }, bossesKilled = { true , false , true }, } If you wanted to save that data normally, you might JSON it and write it to a file, which would end up looking something like this: { \"health\" : 100 , \"points\" : 10 , \"bossesKilled\" :[ true , false , true ], \"maxHealth\" : 100 , \"position\" :{ \"x\" : 10.5591500 , \"y\" : -15.2222000 }, \"name\" : \"John Doe\" } Assuming you truncate the position values like above, that's 137 bytes. Using the following code, that would be cut down to 26 bytes. local BitBuffer = ... -- The BitBuffer should be required here. local buffer = BitBuffer () buffer . writeString ( data . name ) buffer . writeUInt16 ( data . health ) -- This is assuming someone's health will get above 255 but stay below 32,767 buffer . writeUInt16 ( data . maxHealth ) buffer . writeUInt16 ( data . points ) -- Also assuming someone's points will stay rather low buffer . writeFloat32 ( data . position . x ) buffer . writeFloat32 ( data . position . y ) buffer . writeField ( table.unpack ( data . bossesKilled )) -- To do the math: 11 bytes for name (length prefix + raw bytes), 2 each for health, maxHealth, and points, -- 8 for position, and an extra 1 for bossesKilled (though you could write 5 more bools without loosing any space!). -- 11+6+8+1 = 26 local output = buffer . dumpString () -- And then write that to a file On any modern PC, a difference of 95 bytes doesn't matter too much. But if you were limited by space, it would easily be worth taking the time to write the save information like this.","title":"Writing"}]}